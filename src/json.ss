; json.ss
;
;  Copyright (C) 2022, MUKN
;
;  Authors: Henri Lesourd (September 2022)
;
;    This is free software: you can redistribute it and/or modify it under
;    the terms of the Apache 2.0 License or (at your option) any later version.
;

(export #t)
(import ./rexpr)

;; JSon
(define (json-parse S)
  (define (split S CH)
    (define I 0)
    (define N (string-length S))
    (define POS '())
    (define L '())
    (define C Unspecified)
    (define LEV0O 0)
    (define LEV0A 0)
    (define INSTR False)
    (while (< I N)
      (set! C (string-get S I))
      (cond ((== C #\{)
             (if (not INSTR) (set! LEV0O (+ LEV0O 1))))
            ((== C #\})
             (if (not INSTR) (set! LEV0O (- LEV0O 1))))
            ((== C #\[)
             (if (not INSTR) (set! LEV0A (+ LEV0A 1))))
            ((== C #\])
             (if (not INSTR) (set! LEV0A (- LEV0A 1))))
            ((== C #\\)
             (set! I (+ I 1)))
            ((== C #\")
             (set! INSTR (not INSTR)))
            ((and (not INSTR) (== LEV0O 0) (== LEV0A 0) (== C CH))
             (set! POS (cons I POS))))
      (set! I (+ I 1)))
    (set! POS (reverse POS))
    (set! I 0)
    (for-each (=> (J)
                (set! L (cons (substring S
                                         (+ I (if (== I 0) 0 1))
                                         J)
                              L))
                (set! I J))
              POS)
    (set! L (if (> I 0)
              (cons (substring S (+ I 1) (string-length S)) L)
              (if (== S "")
                  '()
                  `(,S))))
    (reverse L))
  (define (attr2 S)
    (define L (split S (char ":")))
    (if (not (== (list-length L) 2))
      (error "json-parse::attr=>" S))
    (set! L (map string-trim L))
    (set! L (map json-parse L))
    (set-car! L (attr (sy (car L))))
    L)
  (define (obj S . ARR)
    (set! S (substring S 1 (- (string-length S) 1)))
    (let* ((L (split S (char ",")))
           (OTY0 Void)
           (OTY Void))
      (set! L (map string-trim L))
      (set! L (map (if (empty? ARR) attr2 json-parse) L))
      (if (and (empty? ARR) (pair? L) (not (unspecified? (: L 'TYPE))))
        (begin
          (set! OTY0 (: L 'TYPE))
          (if (string? OTY0)
            (set! OTY0 (json-parse OTY0)))
          (set! OTY (type-by-name OTY0))
          (if (specified? OTY) (:= L 'TYPE OTY))))
      (if (empty? ARR) (if (unspecified? OTY0)
                         (cons `(:TYPE ,(type-by-name "rexpr")) L)
                         L)
                       L)))
  (define (arr S)
    (obj S 1))
  (define S0 (if (> (string-length S) 0)
               (string-get S 0) ;; TODO: have (string-get) return Nil when out of bounds (?)
               Void))
  (set! S (string-trim S))
  (cond ((== S0 Void)
         (error "json-parse : empty string"))
        ((== S0 #\{)
         (obj S))
        ((== S0 #\[)
         (arr S))
        ((== S "\"#!void\"") ;; TODO: harmonize & escape this
         Void)
        ((== S "true")
         True)
        ((== S "false")
         False)
        ((== S "null")
         Nil)
        ((== S0 #\")
         (set! S (substring S 1 (- (string-length S) 1)))
         (if (and (string? S) (> (string-length S) 1) (== (string-ref S 0) #\'))
           (sy (substring S 1 (string-length S)))
           S))
        ((or (char-digit? S0) (== S0 (char "-")) (== S0 (char "+")))
         (string->number S))
        (else
          S)))

(define (json-serialize O)
  (define (obj O)
    (if (== (caar O) ':TYPE)
      (set! O (cdr O)))
    (if (== (caar O) ':ID)
      (set! O (cdr O)))
    (set! O (map (=> (E)
                   (define VAR (symbol->string (car E)))
                   (string+ "\"" (substring VAR 1 (string-length VAR)) "\"" ":" (json-serialize (cadr E))))
                 O))
    (string+ "{" (string-join O ",") "}"))
  (define (arr O)
    (set! O (map json-serialize O))
    (string+ "[" (string-join O ",") "]"))
  (cond ((unspecified? O)
         "\"#!void\"") ;; NOTE: using "#!void" [was: 'should be "undefined" here, but for talking to JS, we need "null" ...']
        ((boolean? O)
	 (if O "true" "false"))
        ((number? O)
         (number->string O))
        ((symbol? O)
         (string+ "\"'" (symbol->string O) "\""))
        ((string? O)
         (string+ "\"" O "\""))
        ((null? O)
         "[]")
        ((rexpr? O)
         (obj O))
        ((pair? O)
         (arr O))))
