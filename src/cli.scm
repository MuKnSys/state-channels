; cli.scm
;
;  Copyright (C) 2022, MUKN
;
;  Authors: Henri Lesourd (July 2022)
;
;    This is free software: you can redistribute it and/or modify it under
;    the terms of the Apache 2.0 License or (at your option) any later version.
;

;; Calls
(define (lstcall C . OPT)
  (set! OPT (and (not (nil? OPT)) (car OPT)))
  (let * ((USER (<: C 'USER))
          (FROM (<: C 'FROM))
          (OUTNB (<: C 'OUTNB))
          (TO (<: C 'TO))
          (INNB (<: C 'INNB))
          (FUNC (<: C 'FUNC))
          (PARM (<: C 'PARM))
          (SIGN_B (<: C 'SIGN_B))
          (SIGN_E (<: C 'SIGN_E))
         )
    (outraw (if OPT "*" " "))
    (outraw "<")
    (outraw OUTNB)
    (outraw " ")
    (>> INNB)
    (outraw ">")
    (outraw FUNC)
    (outraw " ")
    (outraw FROM)
    (outraw "=>")
    (outraw TO)
    (outraw " ")
    (>> PARM)
    (outraw " ")
    (>> SIGN_B)
    (outraw " ")
    (>> SIGN_E)))

(define (lstcalls L . PTR)
  (set! PTR (if (empty? PTR) Nil (car PTR)))
  (while (!= L Nil)
  (let* ((C (car L)))
    (if (specified? C)
    (begin
      (cr)
      (lstcall C (eq? PTR L))))
    (set! L (cdr L)))))

;; Procs
(define (lstproc PR)
  (define UID (<: PR 'UID))
  (define SELF (<: PR 'SELF))
  (outraw (<: PR 'ID))
  (outraw (if (net-resolve PR) "^" "_"))
  (outraw " ")
  (outraw (if (specified? UID) UID "_"))
  (outraw " ")
  (outraw (<: PR 'USER))
  (outraw " ")
  (>> (<: PR 'PEER))
  (if (specified? (<: PR 'FROM))
  (begin
    (outraw "@")
    (outraw (<: (<: PR 'FROM) 'UID))))
  (outraw " ")
  (>> (if (specified? SELF)
        (<: SELF ':ID)
        SELF))
  (cr)
  (outraw "in:")
  (lstcalls (<: PR 'IN) (<: PR 'INPTR))
  (cr)
  (outraw "in!:")
  (lstcalls (<: PR 'IN!))
  (cr)
  (outraw "out:")
  (lstcalls (<: PR 'OUT) (<: PR 'OUTPTR)))

;; Net
(define (netlist)
  (define N 0)
  (hash-for-each (=> (UID PR)
                   (lstproc PR)
                   (cr)
                   (set! N (+ N 1)))
                 (allprocs))
  (out N)
  (outraw " procs"))

;; CLI
(define (cli PROMPT . SCRIPT)
  (define (read-cmd)
    (filter (=> (X) (!= X ""))
            (string-split
              (string-trim
                (if SCRIPT
                  (let* ((CMD (car SCRIPT)))
                    (set! SCRIPT (cdr SCRIPT))
                    (outraw CMD)
                    (cr)
                    CMD)
                  (read-line (current-input-port))))
              (char " "))))
  (define OBJS (make-hash-table))
  (define (cmd CMD PARM)
    (define (p I)
      (if (< I (list-length PARM))
        (list-ref PARM I)
        _))
    (define (p! CMD A I)
      (define P (p I))
      (if (specified? P)
      (begin
        (if (specified? A)
          (rcons CMD A))
        (rcons CMD P))))
    (define (exec F PARM)
      (if (boxed-empty? PARM)
        (set! PARM '()))
      (apply F PARM))
    (cond
      ((== CMD "h")
       (spc (indent))
       (outraw "pr USER UID    : create proc")(cr)
       (outraw "pr- PID        : del proc having PID")(cr)
       (outraw "pr! PID A V    : proc.A := V")(cr)
       (outraw "prog! PID $OBJ : prog(PID) := $OBJ")(cr)
       (outraw "npr PID        : net proc enter")(cr)
       (outraw "npr- PID       : net proc leave")(cr)
       (outraw "cpr [UID]      : current proc")(cr)
       (outraw "_sc! [UID*]    : sc <= procs having the UIDs UID(i)")(cr)
       (outraw "UID ^ MSG      : send MSG to proc named UID")(cr)
       (outraw "prs UID        : proc step")(cr)
       (outraw "pr* [UID]      : all steps")(cr)
       (outraw "lsp            : list procs")(cr)
       (outraw "$VAR ! CONS    : CONS obj & store it in $VAR")(cr)
       (outraw "$VAR ^ MSG     : send MSG to obj stored in $VAR")(cr)
       (outraw "lso [$VAR]     : list obj(s)")(cr)
       (outraw "q              : quit")(cr)
       (outraw "h              : this help"))
      ((== CMD "q")
       (set! FINISHED True))
      ((== CMD "_err")
       (apply error PARM))
      ((== CMD "pr")
       (let* ((CMD (empty)))
         (p! CMD 'USER 0)
         (p! CMD 'UID 1)
         (exec proc CMD)))
      ((== CMD "pr-")
       (hash-remove! _PROC (string->number (p 0))))
      ((== CMD "pr!")
       (let* ((PR (hash-ref (allprocs) (string->number (p 0)))))
         (if (proc? PR)
           (:= PR (sy (p 1)) (p 2)))))
      ((== CMD "prog!")
       (let* ((PR (hash-ref (allprocs) (string->number (p 0)))))
         (if (proc? PR)
           (let* ((P1 (p 1))
                  (OBJ _))
              (set! P1 (substring P1 1 (string-length P1)))
              (set! OBJ (hash-ref OBJS P1))
              (if OBJ
                (:= PR 'SELF OBJ)
                (begin
                  (outraw "Object ")
                  (outraw P1)
                  (outraw " not found")))))))
      ((== CMD "npr")
       (net-enter (hash-ref (allprocs) (string->number (p 0)))))
      ((== CMD "npr-")
       (net-leave (hash-ref (allprocs) (string->number (p 0)))))
      ((== CMD "cpr")
       (let* ((P0 (p 0)))
         (if (specified? P0)
           (begin
             (set! P0 (net-resolve P0))
             (if P0
               (current-proc! P0)
               (outraw (string+ "Proc " (p 0) " is not on the net"))))
           (begin
             (set! P0 (current-proc))
             (if (nil? P0)
               (outraw "No current proc")
               (outraw (<: P0 'ID)))))))
      ((== CMD "_sc")
       (let* ((LP (map (=> (NAME)
                           (if (specified? NAME)
                             (if (== NAME "_")
                               _
                               (let* ((P (net-resolve NAME)))
                                 (if P
                                   P
                                   (outraw (string+ "Proc " NAME " is not on the net")))))))
                        PARM)))
         (map (=> (PR)
                (:= PR 'FROM (car LP))
                (:= PR 'PEER (list-copy (cdr PARM))))
              (cdr LP))))
      ((== CMD "prs")
       (let* ((P0 (p 0)))
         (if (specified? P0)
           (begin
             (set! P0 (net-resolve P0))
             (if P0
               (^ 'step P0)
               (outraw (string+ "Proc " (p 0) " is not on the net")))))))
      ((== CMD "lsp")
       (netlist))
      ((== CMD "lso")
       (let* ((P0 (p 0)))
         (if (specified? P0)
           (let* ((O (hash-ref OBJS P0)))
             (if O
               (>> O)
               (begin
                 (outraw "Object ")
                 (outraw P0)
                 (outraw " not found"))))
           (let* ((L (hash-map->list cons OBJS))
                  (FIRST True))
             (for-each (=> (A)
                         (if (not FIRST)
                           (outraw " "))
                         (set! FIRST False)
                         (outraw (car A))
                        ;(outraw ": ")
                        ;(>> (cdr A))
                       )
                       L)))))
      (else
       (cond
         ((== (p 0) "^") ;; Message
          (if (== "$" (string (string-get CMD 0))) ;; Message to obj
          (let* ((OBJ _))
            (set! CMD (substring CMD 1 (string-length CMD)))
            (set! OBJ (hash-ref OBJS CMD))
            (if OBJ
              (let* ((F (sy (cadr PARM))))
                (set! PARM (cddr PARM))
                (set! PARM (cons OBJ PARM))
                (set! PARM (cons F PARM))
               ;(out PARM)
                (apply ^ PARM))
              (begin
                (outraw "Object ")
                (outraw CMD)
                (outraw " not found"))))
          (begin ;; Message to proc
            (let* ((PR (net-resolve CMD)))
              (if PR
                (let* ((F (sy (cadr PARM))))
                  (set! PARM (cddr PARM))
                  (set! PARM (cons F PARM))
                  (set! PARM (cons PR PARM))
                  (set! PARM (cons 'send PARM))
                 ;(out PARM)
                  (apply ^ PARM)
                )
                (outraw (string+ "Proc " CMD " is not on the net")))
            )))
         )
         ((== (p 0) "!") ;; Create obj
          (let* ((P0 CMD)
                 (O _)
                 (CMD2 (cdr PARM))
                )
            (if (== "$" (string (string-get P0 0)))
              (set! P0 (substring P0 1 (string-length P0))))
            (set-car! CMD2 (sy (car CMD2)))
            (set! O (eval CMD2 (interaction-environment)))
            (hash-set! OBJS P0 O)
          )
         )
         (else
           (outraw "Unknown command"))))))
  (define CMD _)
  (define FINISHED False)
  (if (not (empty? SCRIPT))
    (set! SCRIPT (car SCRIPT))
    (set! SCRIPT False))
  (while (not FINISHED)
    (if (and SCRIPT (empty? SCRIPT))
      (set! FINISHED True)
      (begin
        (outraw PROMPT)
        (set! CMD (read-cmd))
        (if (or (empty? CMD)
                (== (string-length (car CMD)) 0)
                (== (string-get (car CMD) 0) (char "#")))
          (noop)
          (begin
            (catch-all (=> ()
              (indent+ 2)
              (atcol0 1)
              (cmd (car CMD) (cdr CMD))))
            (indent+ -2)))
        (if (not _COL0)
          (cr))))
  )
)
